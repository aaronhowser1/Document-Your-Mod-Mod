package com.aaronhowser1.documentmod.json;

import com.aaronhowser1.documentmod.DocumentMod;
import com.aaronhowser1.documentmod.json.stacks.BlockStackFactory;
import com.aaronhowser1.documentmod.json.stacks.EnchantedBookStackFactory;
import com.aaronhowser1.documentmod.json.stacks.ItemAllNbtInSearchStackFactory;
import com.aaronhowser1.documentmod.json.stacks.ItemStackFactory;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSyntaxException;
import net.minecraft.item.ItemStack;
import net.minecraft.util.JsonUtils;
import net.minecraft.util.ResourceLocation;

import javax.annotation.Nonnull;
import java.util.List;
import java.util.Map;
import java.util.Random;

public final class ModDocumentation {

    private static final Random RANDOM = new Random(2003576509854125L);
    private static final List<Long> ALREADY_GENERATED_RANDOMS = Lists.newArrayList();
    private static final Map<ResourceLocation, StackFactory> STACK_FACTORIES = Maps.newHashMap();

    private final ItemStack itemStack;
    private final List<String> translationKeys;
    private final ResourceLocation registryName;

    private ModDocumentation(@Nonnull final ItemStack itemStack, @Nonnull final List<String> translationKeys,
                             @Nonnull final ResourceLocation registryName) {
        this.itemStack = itemStack;
        this.translationKeys = translationKeys;
        this.registryName = registryName;
    }

    static {
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "item"), new ItemStackFactory());
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "block"), new BlockStackFactory());
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "enchanted_book"), new EnchantedBookStackFactory());
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "item_all_nbt_in_search"), new ItemAllNbtInSearchStackFactory());
    }

    @Nonnull
    static List<ModDocumentation> create(@Nonnull final JsonObject object, @Nonnull final ResourceLocation name) {
        final List<ItemStack> stacks = getItemStacksIntoList(JsonUtils.getJsonArray(object, "for"));
        if (stacks.isEmpty()) return ImmutableList.of();

        final List<ModDocumentation> returningList = Lists.newArrayList();

        final List<String> translationKeys = parseTranslationKeys(JsonUtils.getJsonArray(object, "documentation"));

        if (stacks.size() == 1) {
            returningList.add(new ModDocumentation(stacks.get(0), translationKeys, name));
            return ImmutableList.copyOf(returningList);
        }

        for (final ItemStack stack : stacks) {
            final StringBuilder nameBuilder = new StringBuilder();
            nameBuilder.append(name.toString());
            nameBuilder.append(".__autogenerated_name.$.");
            final ResourceLocation stackRegistryName = stack.getItem().getRegistryName();
            nameBuilder.append(stackRegistryName != null ? stackRegistryName.toString().replace(':', '$') : "registry_name_not_valid");
            nameBuilder.append(".metadata.");
            nameBuilder.append(stack.getMetadata());
            nameBuilder.append(".$._hash__self_gen_");
            nameBuilder.append(generateRandom());
            final ResourceLocation registryName = new ResourceLocation(nameBuilder.toString());
            returningList.add(new ModDocumentation(stack, translationKeys, registryName));
        }

        return ImmutableList.copyOf(returningList);
    }

    private static long generateRandom() {
        long value;
        do {
            value = Math.abs(RANDOM.nextLong());
        } while (ALREADY_GENERATED_RANDOMS.contains(value));
        ALREADY_GENERATED_RANDOMS.add(value);
        return value;
    }

    @Nonnull
    private static List<ItemStack> getItemStacksIntoList(@Nonnull final JsonArray jsonArray) {
        final List<ItemStack> returningList = Lists.newArrayList();
        jsonArray.forEach(element -> {
            if (!element.isJsonObject()) throw new JsonSyntaxException("for elements must be objects");
            final JsonObject jsonObject = element.getAsJsonObject();
            final List<ItemStack> stack = parseItemStackJsonObject(jsonObject);
            if (!stack.isEmpty()) returningList.addAll(stack);
        });
        return returningList;
    }

    @Nonnull
    private static List<ItemStack> parseItemStackJsonObject(@Nonnull final JsonObject jsonObject) {
        final String type = JsonUtils.getString(jsonObject, "type");
        if (type.trim().isEmpty()) throw new JsonSyntaxException("Type cannot be empty");
        if (type.indexOf(':') == -1) throw new JsonSyntaxException("Missing namespace for type '" + type + "'");
        final StackFactory stackFactory = STACK_FACTORIES.getOrDefault(new ResourceLocation(type), null);
        if (stackFactory == null) {
            throw new JsonParseException("Unable to find stack factory for given type " + type);
        }
        return stackFactory.parseFromJson(jsonObject);
    }

    @Nonnull
    private static List<String> parseTranslationKeys(@Nonnull final JsonArray array) {
        if (array.size() <= 0) throw new JsonSyntaxException("The documentation array must contain at least one string");
        final List<String> translationKeys = Lists.newArrayList();
        for (int i = 0; i < array.size(); ++i) {
            final String key = JsonUtils.getString(array.get(i), "documentation[" + i + "]");
            if (!DocumentMod.proxy.canTranslate(key)) DocumentMod.logger.warn("Found non-translated key " + key + ". Please check your language file");
            translationKeys.add(key);
        }
        return translationKeys;
    }

    @Nonnull
    public ResourceLocation getRegistryName() {
        return this.registryName;
    }

    @Nonnull
    public ItemStack getReferredStack() {
        return this.itemStack.copy();
    }

    @Nonnull
    public List<String> getTranslationKeys() {
        return ImmutableList.copyOf(this.translationKeys);
    }

    @Override
    public String toString() {
        return "ModDocumentation(" + this.hashCode() + "){" +
                "itemStack=" + this.itemStack +
                ", translationKeys=" + this.translationKeys +
                ", registryName=" + this.registryName +
                '}';
    }
}
