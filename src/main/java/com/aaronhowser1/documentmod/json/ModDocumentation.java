package com.aaronhowser1.documentmod.json;

import com.aaronhowser1.documentmod.DocumentMod;
import com.aaronhowser1.documentmod.json.stacks.BlockStackFactory;
import com.aaronhowser1.documentmod.json.stacks.EnchantedBookStackFactory;
import com.aaronhowser1.documentmod.json.stacks.ItemAllNbtInSearchStackFactory;
import com.aaronhowser1.documentmod.json.stacks.ItemStackFactory;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSyntaxException;
import net.minecraft.item.ItemStack;
import net.minecraft.util.JsonUtils;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.text.TextFormatting;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nonnull;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;

public final class ModDocumentation {

    private static final Random RANDOM = new Random(2003576509854125L);
    private static final List<Long> ALREADY_GENERATED_RANDOMS = Lists.newArrayList();
    private static final Map<ResourceLocation, StackFactory> STACK_FACTORIES = Maps.newHashMap();

    private final ItemStack itemStack;
    private final List<String> translationKeys;
    private final List<Pair<TextFormatting, String>> tooltipKeys;
    private final ResourceLocation registryName;

    private ModDocumentation(@Nonnull final ItemStack itemStack, @Nonnull final List<String> translationKeys,
                             @Nonnull final List<Pair<TextFormatting, String>> tooltipKeys, @Nonnull final ResourceLocation registryName) {
        this.itemStack = itemStack;
        this.translationKeys = translationKeys;
        this.tooltipKeys = tooltipKeys;
        this.registryName = registryName;
    }

    static {
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "item"), new ItemStackFactory());
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "block"), new BlockStackFactory());
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "enchanted_book"), new EnchantedBookStackFactory());
        STACK_FACTORIES.put(new ResourceLocation(DocumentMod.MODID, "item_all_nbt_in_search"), new ItemAllNbtInSearchStackFactory());
    }

    @Nonnull
    static List<ModDocumentation> create(@Nonnull final JsonObject object, @Nonnull final ResourceLocation name) {
        final List<ItemStack> stacks = getItemStacksIntoList(JsonUtils.getJsonArray(object, "for"));
        if (stacks.isEmpty()) return ImmutableList.of();

        final List<ModDocumentation> returningList = Lists.newArrayList();

        final List<String> translationKeys = parseTranslationKeys(JsonUtils.getJsonArray(object, "documentation"));
        final List<Pair<TextFormatting, String>> tooltipKeys = parseTooltipKeys(object);

        if (stacks.size() == 1) {
            returningList.add(new ModDocumentation(stacks.get(0), translationKeys, tooltipKeys, name));
            return ImmutableList.copyOf(returningList);
        }

        for (final ItemStack stack : stacks) {
            final StringBuilder nameBuilder = new StringBuilder();
            nameBuilder.append(name.toString());
            nameBuilder.append(".__autogenerated_name.$.");
            final ResourceLocation stackRegistryName = stack.getItem().getRegistryName();
            nameBuilder.append(stackRegistryName != null ? stackRegistryName.toString().replace(':', '$') : "registry_name_not_valid");
            nameBuilder.append(".metadata.");
            nameBuilder.append(stack.getMetadata());
            nameBuilder.append(".$._hash__self_gen_");
            nameBuilder.append(generateRandom());
            final ResourceLocation registryName = new ResourceLocation(nameBuilder.toString());
            returningList.add(new ModDocumentation(stack, translationKeys, tooltipKeys, registryName));
        }

        return ImmutableList.copyOf(returningList);
    }

    private static long generateRandom() {
        long value;
        do {
            value = Math.abs(RANDOM.nextLong());
        } while (ALREADY_GENERATED_RANDOMS.contains(value));
        ALREADY_GENERATED_RANDOMS.add(value);
        return value;
    }

    @Nonnull
    private static List<ItemStack> getItemStacksIntoList(@Nonnull final JsonArray jsonArray) {
        final List<ItemStack> returningList = Lists.newArrayList();
        jsonArray.forEach(element -> {
            if (!element.isJsonObject()) throw new JsonSyntaxException("for elements must be objects");
            final JsonObject jsonObject = element.getAsJsonObject();
            final List<ItemStack> stack = parseItemStackJsonObject(jsonObject);
            if (!stack.isEmpty()) returningList.addAll(stack);
        });
        return returningList;
    }

    @Nonnull
    private static List<ItemStack> parseItemStackJsonObject(@Nonnull final JsonObject jsonObject) {
        final String type = JsonUtils.getString(jsonObject, "type");
        if (type.trim().isEmpty()) throw new JsonSyntaxException("Type cannot be empty");
        if (type.indexOf(':') == -1) throw new JsonSyntaxException("Missing namespace for type '" + type + "'");
        final StackFactory stackFactory = STACK_FACTORIES.getOrDefault(new ResourceLocation(type), null);
        if (stackFactory == null) {
            throw new JsonParseException("Unable to find stack factory for given type " + type);
        }
        return stackFactory.parseFromJson(jsonObject);
    }

    @Nonnull
    private static List<String> parseTranslationKeys(@Nonnull final JsonArray array) {
        if (array.size() <= 0) throw new JsonSyntaxException("The documentation array must contain at least one string");
        final List<String> translationKeys = Lists.newArrayList();
        for (int i = 0; i < array.size(); ++i) {
            final String key = JsonUtils.getString(array.get(i), "documentation[" + i + "]");
            if (!DocumentMod.proxy.canTranslate(key)) DocumentMod.logger.warn("Found non-translated key " + key + ". Please check your language file");
            translationKeys.add(key);
        }
        return translationKeys;
    }

    @Nonnull
    private static List<Pair<TextFormatting, String>> parseTooltipKeys(@Nonnull final JsonObject object) {
        if (!object.has("tooltip")) return ImmutableList.of();
        return parseTooltipKeys(JsonUtils.getJsonArray(object, "tooltip"));
    }

    @Nonnull
    private static List<Pair<TextFormatting, String>> parseTooltipKeys(@Nonnull final JsonArray array) {
        final List<Pair<TextFormatting, String>> list = Lists.newArrayList();
        array.forEach(element -> {
            final Pair<TextFormatting, String> pair;
            if (element.isJsonPrimitive()) {
                // It is a string
                final String string = JsonUtils.getString(element, "tooltip[?]");
                pair = ImmutablePair.of(null, string);
            } else if (element.isJsonObject()) {
                final JsonObject jsonObject = element.getAsJsonObject();
                final String key = JsonUtils.getString(jsonObject, "key");
                final String formatting = JsonUtils.getString(jsonObject, "formatting");
                TextFormatting textFormatting;
                try {
                    textFormatting = TextFormatting.valueOf(formatting.toUpperCase(Locale.ENGLISH));
                } catch (final IllegalArgumentException e) {
                    DocumentMod.logger.warn("No such formatting value exists for " + formatting + "! Reverting to no formatting: please check your JSON files");
                    textFormatting = null;
                }
                pair = ImmutablePair.of(textFormatting, key);
            } else {
                throw new JsonSyntaxException("Array elements of tooltip can be only Strings or Objects");
            }
            if (!DocumentMod.proxy.canTranslate(pair.getRight())) DocumentMod.logger.warn("Found non-translated key " + pair.getRight() + ". Please check your language file");
            list.add(pair);
        });
        return list;
    }

    @Nonnull
    public ResourceLocation getRegistryName() {
        return this.registryName;
    }

    @Nonnull
    public ItemStack getReferredStack() {
        return this.itemStack.copy();
    }

    @Nonnull
    public List<String> getTranslationKeys() {
        return ImmutableList.copyOf(this.translationKeys);
    }

    @Nonnull
    public List<Pair<TextFormatting, String>> getTooltipKeys() {
        return ImmutableList.copyOf(this.tooltipKeys);
    }

    @Override
    public String toString() {
        return "ModDocumentation(" + this.hashCode() + "){" +
                "itemStack=" + this.itemStack +
                ", translationKeys=" + this.translationKeys +
                ", tooltipKeys=" + this.tooltipKeys +
                ", registryName=" + this.registryName +
                '}';
    }
}
