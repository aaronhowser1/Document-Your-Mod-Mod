package com.aaronhowser1.documentmod.json;

import com.aaronhowser1.documentmod.DocumentMod;
import com.aaronhowser1.documentmod.json.stacks.BlockStackFactory;
import com.aaronhowser1.documentmod.json.stacks.ItemStackFactory;
import com.aaronhowser1.documentmod.quark.QuarkEnchantedBookStackFactory;
import com.aaronhowser1.documentmod.tconstruct.TinkerNbtStackFactory;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSyntaxException;
import net.minecraft.item.ItemStack;
import net.minecraft.util.JsonUtils;
import net.minecraft.util.ResourceLocation;

import javax.annotation.Nonnull;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

public final class ModDocumentation {

    private static final Random RANDOM = ThreadLocalRandom.current();
    private static final Map<String, StackFactory> STACK_FACTORIES = Maps.newHashMap();

    private final ItemStack itemStack;
    private final List<String> translationKeys;
    private final ResourceLocation registryName;

    private ModDocumentation(@Nonnull final ItemStack itemStack, @Nonnull final List<String> translationKeys,
                             @Nonnull final ResourceLocation registryName) {
        this.itemStack = itemStack;
        this.translationKeys = translationKeys;
        this.registryName = registryName;
    }

    static {
        STACK_FACTORIES.put("dym:item", new ItemStackFactory());
        STACK_FACTORIES.put("dym:block", new BlockStackFactory());
        STACK_FACTORIES.put("quark:enchantment_book", new QuarkEnchantedBookStackFactory());
        STACK_FACTORIES.put("tconstruct:nbt_tool", new TinkerNbtStackFactory());
    }

    @Nonnull
    static List<ModDocumentation> create(@Nonnull final JsonObject object, @Nonnull final ResourceLocation name) {
        final List<ItemStack> stacks = getItemStacksIntoList(JsonUtils.getJsonArray(object, "for"));
        if (stacks.isEmpty()) return ImmutableList.of();

        final List<ModDocumentation> returningList = Lists.newArrayList();

        final List<String> translationKeys = parseTranslationKeys(JsonUtils.getJsonArray(object, "documentation"));

        if (stacks.size() == 1) {
            returningList.add(new ModDocumentation(stacks.get(0), translationKeys, name));
            return ImmutableList.copyOf(returningList);
        }

        for (final ItemStack stack : stacks) {
            final StringBuilder nameBuilder = new StringBuilder();
            nameBuilder.append(name.toString());
            nameBuilder.append(".__autogenerated_name.$.");
            final ResourceLocation stackRegistryName = stack.getItem().getRegistryName();
            nameBuilder.append(stackRegistryName != null ? stackRegistryName.toString().replace(':', '$') : "registry_name_not_valid");
            nameBuilder.append(".metadata.");
            nameBuilder.append(stack.getMetadata());
            nameBuilder.append(".$._hash__self_gen_");
            nameBuilder.append(RANDOM.nextInt(Integer.MAX_VALUE));
            final ResourceLocation registryName = new ResourceLocation(nameBuilder.toString());
            returningList.add(new ModDocumentation(stack, translationKeys, registryName));
        }

        return ImmutableList.copyOf(returningList);
    }

    @Nonnull
    private static List<ItemStack> getItemStacksIntoList(@Nonnull final JsonArray jsonArray) {
        final List<ItemStack> returningList = Lists.newArrayList();
        jsonArray.forEach(element -> {
            if (!element.isJsonObject()) throw new JsonSyntaxException("for elements must be objects");
            final JsonObject jsonObject = element.getAsJsonObject();
            final List<ItemStack> stack = parseItemStackJsonObject(jsonObject);
            if (!stack.isEmpty()) returningList.addAll(stack);
        });
        return returningList;
    }

    @Nonnull
    private static List<ItemStack> parseItemStackJsonObject(@Nonnull final JsonObject jsonObject) {
        final String type = JsonUtils.getString(jsonObject, "type");
        final StackFactory stackFactory = STACK_FACTORIES.getOrDefault(type, STACK_FACTORIES.getOrDefault("dym:" + type, null));
        if (stackFactory == null) {
            throw new JsonParseException("Unable to find stack factory for given type " + type);
        }
        return stackFactory.parseFromJson(jsonObject);
    }

    @Nonnull
    private static List<String> parseTranslationKeys(@Nonnull final JsonArray array) {
        if (array.size() <= 0) throw new JsonSyntaxException("The documentation array must contain at least one string");
        final List<String> translationKeys = Lists.newArrayList();
        for (int i = 0; i < array.size(); ++i) {
            final String key = JsonUtils.getString(array.get(i), "documentation[" + i + "]");
            if (!DocumentMod.proxy.canTranslate(key)) DocumentMod.logger.warn("Found non-translated key " + key + ". Please check your language file");
            translationKeys.add(key);
        }
        return translationKeys;
    }

    @Nonnull
    public ResourceLocation getRegistryName() {
        return this.registryName;
    }

    @Nonnull
    public ItemStack getReferredStack() {
        return this.itemStack.copy();
    }

    @Nonnull
    public List<String> getTranslationKeys() {
        return ImmutableList.copyOf(this.translationKeys);
    }

    @Override
    public String toString() {
        return "ModDocumentation(" + this.hashCode() + "){" +
                "itemStack=" + this.itemStack +
                ", translationKeys=" + this.translationKeys +
                ", registryName=" + this.registryName +
                '}';
    }
}
